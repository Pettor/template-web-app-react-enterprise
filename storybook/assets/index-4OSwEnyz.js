import{S as A,H as x,F as a,an as V,a3 as E,u as C,o as l,a4 as F}from"./add-dom-event-LYOn49tU.js";import{k as I,y as b}from"./resolve-motion-value-BAmjP_zU.js";import{r as O}from"./iframe-rb5u8kG-.js";import{i as P}from"./chunk-6VC6TS2O-bSW3gb1N.js";import"./resolve-transition-BRWD_pRL.js";import"./preload-helper-PPVm8Dsz.js";import"./useFocusRing-Xo4cRvQI.js";import"./chunk-BGEKJ4Q5-DzVAaTre.js";import"./index-CX-lnvfg.js";import"./index-A0a1QD7y.js";const k=(e,t)=>t.isSVG??P(e)?new A(t):new x(t,{allowProjection:e!==O.Fragment});class G extends a{constructor(t){super(t),t.animationState||(t.animationState=V(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();I(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:n}=this.node.prevProps||{};t!==n&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let H=0;class T extends a{constructor(){super(...arguments),this.id=H++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:n}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const o=this.node.animationState.setActive("exit",!t);n&&!t&&o.then(()=>{n(this.id)})}mount(){const{register:t,onExitComplete:n}=this.node.presenceContext||{};n&&n(this.id),t&&(this.unmount=t(this.id))}unmount(){}}const M={animation:{Feature:G},exit:{Feature:T}};function S(e){return{point:{x:e.pageX,y:e.pageY}}}function f(e,t,n){const{props:s}=e;e.animationState&&s.whileHover&&e.animationState.setActive("whileHover",n==="Start");const o="onHover"+n,i=s[o];i&&b.postRender(()=>i(t,S(t)))}class N extends a{mount(){const{current:t}=this.node;t&&(this.unmount=E(t,(n,s)=>(f(this.node,s,"Start"),o=>f(this.node,o,"End"))))}unmount(){}}class B extends a{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=C(l(this.node.current,"focus",()=>this.onFocus()),l(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function v(e,t,n){const{props:s}=e;if(e.current instanceof HTMLButtonElement&&e.current.disabled)return;e.animationState&&s.whileTap&&e.animationState.setActive("whileTap",n==="Start");const o="onTap"+(n==="End"?"":n),i=s[o];i&&b.postRender(()=>i(t,S(t)))}class L extends a{mount(){const{current:t}=this.node;if(!t)return;const{globalTapTarget:n,propagate:s}=this.node.props;this.unmount=F(t,(o,i)=>(v(this.node,i,"Start"),(u,{success:c})=>v(this.node,u,c?"End":"Cancel")),{useGlobalTarget:n,stopPropagation:s?.tap===!1})}unmount(){}}const h=new WeakMap,m=new WeakMap,R=e=>{const t=h.get(e.target);t&&t(e)},_=e=>{e.forEach(R)};function y({root:e,...t}){const n=e||document;m.has(n)||m.set(n,{});const s=m.get(n),o=JSON.stringify(t);return s[o]||(s[o]=new IntersectionObserver(_,{root:e,...t})),s[o]}function D(e,t,n){const s=y(t);return h.set(e,n),s.observe(e),()=>{h.delete(e),s.unobserve(e)}}const W={some:0,all:1};class j extends a{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:n,margin:s,amount:o="some",once:i}=t,u={root:n?n.current:void 0,rootMargin:s,threshold:typeof o=="number"?o:W[o]},c=p=>{const{isIntersecting:r}=p;if(this.isInView===r||(this.isInView=r,i&&!r&&this.hasEnteredView))return;r&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",r);const{onViewportEnter:g,onViewportLeave:w}=this.node.getProps(),d=r?g:w;d&&d(p)};return D(this.node.current,u,c)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:n}=this.node;["amount","margin","root"].some(J(t,n))&&this.startObserver()}unmount(){}}function J({viewport:e={}},{viewport:t={}}={}){return n=>e[n]!==t[n]}const U={inView:{Feature:j},tap:{Feature:L},focus:{Feature:B},hover:{Feature:N}},X={renderer:k,...M,...U};var st=X;export{st as default};
