import{S as A,H as x,F as a,an as V,a3 as E,u as C,o as l,a4 as F}from"./add-dom-event-Cz7ramGW.js";import{ed as I,W as O,ba as P,f as b}from"./index-BkDfcGXb.js";const k=(e,t)=>t.isSVG??I(e)?new A(t):new x(t,{allowProjection:e!==O.Fragment});class G extends a{constructor(t){super(t),t.animationState||(t.animationState=V(t))}updateAnimationControlsSubscription(){const{animate:t}=this.node.getProps();P(t)&&(this.unmountControls=t.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:t}=this.node.getProps(),{animate:n}=this.node.prevProps||{};t!==n&&this.updateAnimationControlsSubscription()}unmount(){this.node.animationState.reset(),this.unmountControls?.()}}let H=0;class T extends a{constructor(){super(...arguments),this.id=H++}update(){if(!this.node.presenceContext)return;const{isPresent:t,onExitComplete:n}=this.node.presenceContext,{isPresent:s}=this.node.prevPresenceContext||{};if(!this.node.animationState||t===s)return;const o=this.node.animationState.setActive("exit",!t);n&&!t&&o.then(()=>{n(this.id)})}mount(){const{register:t,onExitComplete:n}=this.node.presenceContext||{};n&&n(this.id),t&&(this.unmount=t(this.id))}unmount(){}}const M={animation:{Feature:G},exit:{Feature:T}};function S(e){return{point:{x:e.pageX,y:e.pageY}}}function f(e,t,n){const{props:s}=e;e.animationState&&s.whileHover&&e.animationState.setActive("whileHover",n==="Start");const o="onHover"+n,i=s[o];i&&b.postRender(()=>i(t,S(t)))}class N extends a{mount(){const{current:t}=this.node;t&&(this.unmount=E(t,(n,s)=>(f(this.node,s,"Start"),o=>f(this.node,o,"End"))))}unmount(){}}class B extends a{constructor(){super(...arguments),this.isActive=!1}onFocus(){let t=!1;try{t=this.node.current.matches(":focus-visible")}catch{t=!0}!t||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=C(l(this.node.current,"focus",()=>this.onFocus()),l(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}function v(e,t,n){const{props:s}=e;if(e.current instanceof HTMLButtonElement&&e.current.disabled)return;e.animationState&&s.whileTap&&e.animationState.setActive("whileTap",n==="Start");const o="onTap"+(n==="End"?"":n),i=s[o];i&&b.postRender(()=>i(t,S(t)))}class L extends a{mount(){const{current:t}=this.node;if(!t)return;const{globalTapTarget:n,propagate:s}=this.node.props;this.unmount=F(t,(o,i)=>(v(this.node,i,"Start"),(u,{success:c})=>v(this.node,u,c?"End":"Cancel")),{useGlobalTarget:n,stopPropagation:s?.tap===!1})}unmount(){}}const m=new WeakMap,h=new WeakMap,R=e=>{const t=m.get(e.target);t&&t(e)},W=e=>{e.forEach(R)};function _({root:e,...t}){const n=e||document;h.has(n)||h.set(n,{});const s=h.get(n),o=JSON.stringify(t);return s[o]||(s[o]=new IntersectionObserver(W,{root:e,...t})),s[o]}function D(e,t,n){const s=_(t);return m.set(e,n),s.observe(e),()=>{m.delete(e),s.unobserve(e)}}const j={some:0,all:1};class y extends a{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:t={}}=this.node.getProps(),{root:n,margin:s,amount:o="some",once:i}=t,u={root:n?n.current:void 0,rootMargin:s,threshold:typeof o=="number"?o:j[o]},c=d=>{const{isIntersecting:r}=d;if(this.isInView===r||(this.isInView=r,i&&!r&&this.hasEnteredView))return;r&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",r);const{onViewportEnter:g,onViewportLeave:w}=this.node.getProps(),p=r?g:w;p&&p(d)};return D(this.node.current,u,c)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:t,prevProps:n}=this.node;["amount","margin","root"].some(J(t,n))&&this.startObserver()}unmount(){}}function J({viewport:e={}},{viewport:t={}}={}){return n=>e[n]!==t[n]}const U={inView:{Feature:y},tap:{Feature:L},focus:{Feature:B},hover:{Feature:N}},X={renderer:k,...M,...U};var z=X;export{z as default};
